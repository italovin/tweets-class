@using blazor_test.Models
@using blazor_test.Repositories
@using System.Text.RegularExpressions
@using Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage
@inherits QuestionsSection
@inject ProtectedSessionStorage ProtectedSessionStore
@inject AccessKeyRepository AccessKeyRepository
@inject LabelingRepository LabelingRepository

@if(LabelingsResponse == null){
    <p><em>Respostas não encontradas</em></p>
} else {
<div>
    <h3>Revisão das classificações</h3>
    <hr>
    <table class="table">
        <thead>
            <tr>
                <th>Questão</th>
                <th>Frase</th>
                <th>Classificação</th>
            </tr>
        </thead>
        <tbody>
            @for(int i = 0; i < LabelingsResponse.Count; i++){
                <tr>
                    <td>@(i+1)</td>
                    <td>@Phrases[i].Text</td>
                    <td>@LabelParser.ParseLabel((LabelEnum)LabelingsResponse[i].Label)</td>
                </tr>
            }
        </tbody>
    </table>
    <button class="btn btn-primary" @onclick="ToFormSection">Refazer</button>
    <hr>
    <p>Insira a chave de acesso para envio das respostas</p>
    <div class="form-floating mb-3">
        <input type="password" placeholder="Chave de acesso" @bind="accessKeyString">
    </div>
    <div class="mb-3">
        <div>
            <button class="btn btn-primary mb-2" @onclick="SendResponse">Enviar</button>
        </div>
        @if(validating){
            <div class="spinner-border text-primary" role="status">
            </div>  
        } else {
            <div class="text-danger">
                @accessKeyStatusMessage.Message
            </div>
        }
    </div>
</div>
}

@code{
    [Parameter]
    public List<Phrase> Phrases { get; set; } = new();
    [Parameter]
    public List<Labeling> LabelingsResponse { get; set; } = new();
    [Parameter]
    public EventCallback<List<Labeling>> LabelingsResponseChanged { get; set; }
    private KeyValidationMessage accessKeyStatusMessage = new();
    private string accessKeyString = "";
    private bool validating = false;
    
    private async Task SendResponse(){
        validating = true;
        await Task.Yield();
        AccessKey? accessKey = null;
        accessKeyStatusMessage = await ValidateAccessKeyInput(accessKey);
        if(!accessKeyStatusMessage.IsError && accessKey is not null){
            var SendLabelingsResponseTask = LabelingRepository.LabelPhrasesList(LabelingsResponse);
            var RevokeAccessKeyTask = AccessKeyRepository.RevokeAccessKey(accessKey);
            var ToConcludedSectionTask = ToConcludedSection();
            await ProtectedSessionStore.DeleteAsync("phrases");
            Task.WaitAll(SendLabelingsResponseTask, RevokeAccessKeyTask, ToConcludedSectionTask);
        }
    }

    private async Task<KeyValidationMessage> ValidateAccessKeyInput(AccessKey? accessKey){
        accessKey = null;
        Regex accessKeyRegex = new(@"^([0-9]+)\&([A-Za-z0-9+/=]+)");
        Match match = accessKeyRegex.Match(accessKeyString);
        string accessKeyId = string.Empty;
        string accessKeyCode = string.Empty;
        if(match.Success){
            accessKeyId = match.Groups[1].Value;
            accessKeyCode = match.Groups[2].Value;
        } else {
            validating = false;
            return new(){ Message = "Chave de acesso em formato inválido"};
        }

        bool parsed = int.TryParse(accessKeyId.Trim(), out int id);
        if(!parsed){
            validating = false;
            return new(){ Message = "Id de chave em formato inváldio", IsError = true };
        }
        accessKey = await AccessKeyRepository.GetAccessKey(id);
        if(accessKey is null){
            validating = false;
            return new(){ Message = "Id de chave não existe", IsError = true };
        }
        if(AccessKeyRepository.CheckIfRevoked(accessKey)){
            validating = false;
            return new(){ Message = "Chave já revogada", IsError = true };
        }
        validating = false;
        if(await AccessKeyRepository.ValidateAccessKey(id, accessKeyCode) == true){
            return new(){ Message = string.Empty};
        } else if (await AccessKeyRepository.ValidateAccessKey(id, accessKeyCode) == false){
            return new(){ Message = "Chave de acesso inválida", IsError = true };
        } else {
            return new(){ Message = "Ocorreu algum problema ao buscar a chave", IsError = true };
        }
    }

    private void ToFormSection(){
        LabelingsResponse.Clear();
        var LabelingsResponseChangedTask = LabelingsResponseChanged.InvokeAsync(LabelingsResponse);
        var OnQuestionsStateChangedTask = OnQuestionsStateChanged((int)QuestionsStateEnum.Respond);
        Task.WaitAll(LabelingsResponseChangedTask, OnQuestionsStateChangedTask); 
    }
    private async Task ToConcludedSection(){
        await OnQuestionsStateChanged((int)QuestionsStateEnum.Concluded);
    }
    private class KeyValidationMessage{
        public string Message { get; set; } = string.Empty;
        public bool IsError { get; set; } = false;
    }
}