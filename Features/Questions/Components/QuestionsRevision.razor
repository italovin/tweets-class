@using blazor_test.Models
@using blazor_test.Repositories
@using Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage
@inherits QuestionsSection
@inject ProtectedSessionStorage ProtectedSessionStore
@inject AccessKeyRepository AccessKeyRepository

@if(LabelingsResponse == null){
    <p><em>Respostas não encontradas</em></p>
} else {
<div>
    <h3>Revisão das classificações</h3>
    <hr>
    <table class="table">
        <thead>
            <tr>
                <th>Questão</th>
                <th>Frase</th>
                <th>Classificação</th>
            </tr>
        </thead>
        <tbody>
            @for(int i = 0; i < LabelingsResponse.Count; i++){
                <tr>
                    <td>@(i+1)</td>
                    <td>@Phrases[i].Text</td>
                    <td>@LabelParser.ParseLabel((LabelEnum)LabelingsResponse[i].Label)</td>
                </tr>
            }
        </tbody>
    </table>
    <button class="btn btn-primary" @onclick="ToFormSection">Refazer</button>
    <hr>
    <p>Insira o Id e a chave de autorização para envio das respostas</p>
    <div class="form-floating mb-3">
        <input placeholder="Id da Chave" @bind="accessKeyId">
        <input type="password" placeholder="Chave de autorização" @bind="accessKeyString">
    </div>
    <div>
        <button class="btn btn-primary" @onclick="SendResponse">Enviar</button>
    </div>
    <div class="text-danger">
        @accessKeyStatusMessage.Message
    </div>
</div>
}

@code{
    [Parameter]
    public List<Phrase> Phrases { get; set; } = new();
    [Parameter]
    public List<Labeling> LabelingsResponse { get; set; } = new();
    [Parameter]
    public EventCallback<List<Labeling>> LabelingsResponseChanged { get; set; }
    
    private KeyValidationMessage accessKeyStatusMessage = new();
    private string accessKeyId = "";
    private string accessKeyString = "";

    private async Task SendResponse(){
        accessKeyStatusMessage = ValidateAccessKeyInput(out AccessKey? accessKey);
        if(!accessKeyStatusMessage.IsError && accessKey is not null){
            var RevokeAccessKeyTask = AccessKeyRepository.RevokeAccessKey(accessKey);
            var ToConcludedSectionTask = ToConcludedSection();
            await ProtectedSessionStore.DeleteAsync("phrases");
            Task.WaitAll(RevokeAccessKeyTask, ToConcludedSectionTask);
        }
    }
    private KeyValidationMessage ValidateAccessKeyInput(out AccessKey? accessKey){
        accessKey = null;
        string accessKeyIdTrimmed = accessKeyId.Trim();
        bool parsed = int.TryParse(accessKeyIdTrimmed, out int id);
        if(!parsed)
            return new(){ Message = "Id de chave em formato inváldio", IsError = true };

        accessKey = AccessKeyRepository.GetAccessKey(id);
        if(accessKey is null)
            return new(){ Message = "Id de chave não existe", IsError = true };

        if(AccessKeyRepository.CheckIfRevoked(accessKey))
            return new(){ Message = "Chave já revogada", IsError = true };
            
        if(AccessKeyRepository.ValidateAccessKey(id, accessKeyString) == true){
            return new(){ Message = string.Empty};
        } else if (AccessKeyRepository.ValidateAccessKey(id, accessKeyString) == false){
            return new(){ Message = "Chave de acesso inválida", IsError = true };
        } else {
            return new(){ Message = "Ocorreu algum problema ao buscar a chave", IsError = true };
        }
    }

    private void ToFormSection(){
        LabelingsResponse.Clear();
        var LabelingsResponseChangedTask = LabelingsResponseChanged.InvokeAsync(LabelingsResponse);
        var OnQuestionsStateChangedTask = OnQuestionsStateChanged((int)QuestionsStateEnum.Respond);
        Task.WaitAll(LabelingsResponseChangedTask, OnQuestionsStateChangedTask); 
    }
    private async Task ToConcludedSection(){
        await OnQuestionsStateChanged((int)QuestionsStateEnum.Concluded);
    }
    private class KeyValidationMessage{
        public string Message { get; set; } = string.Empty;
        public bool IsError { get; set; } = false;
    }
}